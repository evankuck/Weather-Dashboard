// Personal API key was generated, const key created and posted here, allows API data to be added to my app
const apikey = "401908c5d78b5ea7ed945ee0817b0f6a"

// WHEN I search for a city
// THEN I am presented with current and future conditions for that city and that city is added to the search history
const submitButton = $("#submitButton")
submitButton.on("click", getLatLonByCityState)

// GIVEN a weather dashboard with form inputs
// Creates button that gets the variable generated by getLatLonByCityState
// call function at the beginning as well
getLatLonByCityState()


// Creates the function "space" on the page that'll be populated by the API's data
function createHTML(data) {
    console.log({
        data
    })

    // Display city/state and time before writing the columns into the table, this will go at the top
    const headingContainer = $("#headingContainer")
    // WHEN I view current weather conditions for that city
    // THEN I am presented with the city name, 
    const cityName = $('#cityInput').val() //pull name of the city from the search event
    const cityNameDisplay = $("<h1>").text(cityName ? cityName : localStorage.getItem("mostRecent")) //name of the city appears 

    const todaysDate = new Date()
    console.log({
        todaysDate
    })
    const dateTimeDisplay = $("<h2>").text(todaysDate)

    // append the city and date to the heading container after we clear it
    headingContainer.html("")
    headingContainer.append(cityNameDisplay, dateTimeDisplay)

    //Creates the actual columns for the API's data
    const container = $("#forecastContainer").html("")
    //iterating through the data
    for (let i = 0; i < data.length; i++) {
        //creating the column like you would in HTML
        const column = $("<div>").addClass("column p-3")


        const weatherType = data[i].weather[0].main
        // displaying the weather through images
        const weatherDisplay = $("<img>").addClass("")
        // defining the source of the images

        console.log(weatherType)
        // an icon representation of weather conditions
        let src = ""
        switch (weatherType) {
            case "Rain":
                src = "./Assets/images/rain_s_cloudy.png"
                break
            case "Sunny":
                src = "./Assets/images/sunny.png"
                break
            case "Partly Cloudy":
                src = "./Assets/images/partly_cloudy.png"
                break
            case "Clouds":
                src = "./Assets/images/cloudy.png"
                break
            default:
                src = "https://via.placeholder.com/200"
                break

        }

        weatherDisplay.attr("src", src).attr("height", 20).attr("width", 20)


        // the temperature
        // add high/low
        // adds weather data, the dot notation is basically digging deeper into the data to find the relevant info
        const highTemperature = data[i].temp.max
        const lowTemperature = data[i].temp.min
        const tempDisplay = $("<div>").text(`${highTemperature} / ${lowTemperature}`)

        // the humidity, 
        const humidityDisplay = $("<div>").text(data[i].humidity)

        // the wind speed,
        const windSpeedDisplay = $("<div>").text(data[i].wind_speed)

        // WHEN I view the UV index
        // THEN I am presented with a color that indicates whether the conditions are favorable, moderate, or severe
        // and the UV index
        // add uv (do a couple if statements that will add conditionally the classes favorable, moderate, and severe which will be color coded in CSS classes)

        const uvIndex = data[i].uvi
        const uvDisplay = $("<div>").text(uvIndex)
        if (uvIndex >= 0 && uvIndex <= 2) {
            uvDisplay.css("background-color", "#00FF00"); //green for favorable
        } else if (uvIndex >= 3 && uvIndex <= 7) {
            uvDisplay.css("background-color", "#FFA500"); //orange for moderate
        } else if (uvIndex >= 8 && uvIndex <= 12) {
            uvDisplay.css("background-color", "#ff0000"); //red for severe
        } else {
            uvDisplay.css("background-color", "#FFFFFF");
        }


        // and then append elements to column, in order
        column.append(weatherDisplay)
        column.append(tempDisplay)
        column.append(humidityDisplay)
        column.append(windSpeedDisplay)
        column.append(uvDisplay)
        //append column to container after all sub elements are added
        container.append(column)


        const searchHistoryContainer = $("#searchHistory")
        searchHistoryContainer.html("")
        const history = JSON.parse(localStorage.getItem("history"))
        for (let i = 0; i < history.length; i++) {
            // create a button for each item in search history
            const button = $("<button>").on("click", getLatLonByCityState).text(history[i])
            searchHistoryContainer.append(button)
        }
    }
}


function getLatLonByCityState(event) {
    console.log(event ? event.target.innerText : "")
    if (event) {
        event.preventDefault() // this line prevents the page from being refreshed when clicked (because its a submit button)
    }

    const string = $("#cityInput").val()
    const cityStr = string.split(",")[0]
    const stateStr = string.split(",")[1]
    // we "let" city and state in function scope so that our if/else statements can access the variable and reassign a new value (because its not a const). Our city and state should have new values after the following if/else statements based on if there was data from #cityInput or if a search history button was pressed and if not then use localStorage's mostRecent
    let city = ""
    let state = ""
    if (cityStr && stateStr) {
        city = cityStr
        state = stateStr
        localStorage.setItem("mostRecent", `${city},${state}`)
    } else if (event && event.target && event.target.innerText && event.target.innerText !== "Submit") {
        city = event.target.innerText.split(",")[0]
        state = event.target.innerText.split(",")[1]
    } else {
        const mostRecentCityState = localStorage.getItem("mostRecent") // should give us a City,State combo
        city = mostRecentCityState.split(",")[0]
        state = mostRecentCityState.split(",")[1]
    }
    console.log(city, state);

    if (city && state) {
        const history = JSON.parse(localStorage.getItem("history")) || [] // initialize as an empty array if its not in localstorage
        history.push(`${city},${state}`) // push the city,state to the array
        // put the array back in locastorage

        localStorage.setItem("history", JSON.stringify(history))

        // once we finall have our city and state defined we can make an api call to the openweathermap GEO api and get geolocation data for lat/lon to then...
        $.ajax(`http://api.openweathermap.org/geo/1.0/direct?q=${city},${state},US&limit=1&appid=${apikey}`)
            .then(function (data) {
                console.log(data)
                const {
                    lat,
                    lon
                } = data[0] // destructure syntax
                //  const lat = data[0].lat
                //  const lon = data[0].lon
                // ...to then use lat/lon to make another api call to the openweathmap but for the ONECALL api which will grab weather data... 
                getForecastByLatLon(lat, lon)
            })
    }
}

function getForecastByLatLon(lat, lon) {
    $.ajax(`https://api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&appid=${apikey}`)
        .then(function (data) {
            console.log(data)
            const dailyWeather = data.daily
            console.log({
                dailyWeather
            })
            // once weather data is loaded we pass it to the createHTML function to make all of our forecast columns
            createHTML(dailyWeather)
        })
}




// WHEN I click on a city in the search history
// THEN I am again presented with current and future conditions for that city

// WHEN I open the weather dashboard
// THEN I am presented with the last searched city forecast